# 工作笔记
1. 实际上，如果Vue仅仅依赖`getter`与`setter`，是无法做到在数组调用push,pop等方法时候触发数据响应的，因此Vue实际上是通过劫持这些方法，对这些方法进行包装变异来实现的。

```
var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    // 将 arguments 转换为数组
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];
    var result = original.apply(this, args);
    // 这儿的用法同dependArray(value)，就是为了取得dep
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    // 如果有新的数据插入，则插入的数据也要进行一个响应式
    if (inserted) { ob.observeArray(inserted); }
   // 通知依赖进行更新
    ob.dep.notify();
    return result
  });
```

2. `husky` 配合git可以做代码提交前的检查

3. 生产环境删除`consoloe.log`  可以安装插件`babel-plugin-transform-remove-console`

4. [谷歌远程调试器](https://chrome-devtools-frontend.appspot.com/ ) 开发混合app的时候有用 但是需要梯子。

5. `v-bind`绑定一个对象可以实现多属性值的传递，进行简化

   ```
   <blog-post v-bind="post"></blog-post>
   使用v-bind="post"等于
   <blog-post v-bind:id="post.id" v-bind:title="post.title"></blog-post>
   ```

6. threejs改变模型大小，位置，旋转。几种方法都可以

   ```
   object.scale.multiplyScalar(倍数)
   obj.rotation.x = -0.5 * Math.PI;
   obj.position.set(0, 0, 0);
   ```

7. 加载的文件经过了webpack的处理时，需要把文件放到vue中处理静态文件的文件夹中，在vue-cli3中public文件夹下的文件不需要经过webpack处理，在vue-cli3.0之前就是放在static静态文件文件夹下，在vue-cli3.0中需要放在public文件夹下，通过web服务访问文件夹下文件的路径来引用。

8. vue的插件install方法干了什么事情？

   ```
   //写法1
   exports.install = function (Vue, options) {}
   //写法2
   export default {
     /**
      * Vue.use 需要插件提供一个install方法
      * @param {*} Vue Vue
      * @param {*} options 插件配置信息
      */
     install(Vue, options) {
       console.log(options)
       // 将组件通过Vue.components 进行注册
       Vue.components(Button.name, Button)
   
       // 注册全局指令
       Vue.directive('loading', loadingDirective)
   
       // 将loadingMethod 挂载到 Vue原型链上面，方便调用
       Vue.prototype.$loading = loadingMethod
       
       //甚至可以通过minxin向vue实例全局混入钩子函数，例如vue-router
     }
   }
   ```

   

9. 切记切记项目开发完后自己多测试

   * 多浏览器打开看兼容
   * 多测试业务逻辑
   * PC 站网页的分辨率 1920 1377 等 都要兼容照顾

10. 学习数据结构与算法其实非常有用，但是需要系统性地学习。脱离数据结构谈论算法没有意义。

11. 实现权限控制
    
1. 登录时获取 `token` 保存到本地，接着前端会携带 `token` 再调用获取用户信息的接口获取当前用户的角色信息。
   
    2. 前端再根据当前的角色计算出相应的路由表拼接到常规路由表后面。
    
    3. 路由逻辑: 全局路由拦截，从缓存中获取令牌，存在的话如果首次进入路由需要获取用户信息，生成动态路由，这里需要处理 `/login` 特殊情况，不存在则判断白名单然后走对应的逻辑
    
       动态生成路由: 传入需要 `router.js` 定义的两种路由。判断当前身份是否是管理员，是则直接拼接，否则需要过滤出具备权限的路由，最后拼接到常规路由后面，通过 `addRoutes` 追加。
    
       
    
    * 按钮级别的权限 
      项目中按钮权限注册全局自定义指令来完成的，光有前端来控制绝对不是可行之道。实现较为细致的权限控制需要一个自定义权限验证指令和一个全局验证方法。
    
    ```
    import Vue from "vue";
    import store from "@/store/store";
    //注册一个v-allowed指令
    Vue.directive("allowed", {
      inserted: function(el, bingding) {
        let roles = store.getters.roles;
        //判断权限
        if (Array.isArray(roles) && roles.length > 0) {
      let allow = bingding.value.some(item => {
            return roles.includes(item);
      });
          if (!allow) {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
          }
        }
      }
    });
    ```
    
    
    
12. reduce用起来还是挺有逼格的，接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 还有一个可选参数作为函数的初始值。

    ```
    /**
    *function(total,currentValue, index,arr)
    * initialValue就是上面的total
    */
    计算网页用得最多的标签元素
    Array.from(document.getElementsByTagName("*")).map(i=>i.tagName).reduce((res,a)=>{
    if(res[a]) {
       res[a] += 1
    }else {
        res[a] = 1
    };
    return res
    },{})
    
    ```

    

13. `svg`实现光线流动的效果，经常用于背景或者地图边框的动效，使用`stroke-dasharray`和`stroke-dashoffset`可以实现。

    [SVG学习之stroke-dasharray 和 stroke-dashoffset 详解](https://www.cnblogs.com/daisygogogo/p/11044353.html )

14. `Unable to preventDefault inside passive event listener due to target being treated as passive` 怎么办？

    1. 注册处理函数时，用如下方式，明确声明为不是被动的

       ```
       window.addEventListener(‘touchmove’, func, { passive: false })
       ```

    2. 应用 CSS 属性 `touch-action: none;` 这样任何触摸事件都不会产生默认行为，但是 touch 事件照样触发。

15. 在服务器访问资源的时候的，`./` ,`../`, `/`的不同。自己踩了个坑..

    1. 首先 / 是很少很少会用到的，他代表是指根目录，就和Windows的我的电脑那个位置差不多，当我们用nginx加载资源的时候，他指的就是`location`为/这一级的目录

       >     <script src=/js/iconfont.js></script>

        ![1604047406176](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1604047406176.png)

    2. `./`指的就是相对的路径了，相对于当前访问的位置，比如当前访问/ucare-app就会在他指向的目录下去查找，`../`则是向相对的上一级目录上查找

       ![1604047877773](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1604047877773.png)

16. 判断一个字符串是否可以转成数字

    ```
    isNaN('A') TRUE
    isNaN('3') FALSE
    ```

17. 数组操作`slice`和`splcie`

    数组截取的`api`五花八门，这两个的区别在于

    *  slice方法不会改变原数组，而是返回一个子数组，**同时也可以用于切割字符串**（等同于`substr`，`substring`）

    * 如果想删除数组中的一段元素，应该使用`Array.splice()`方法 , 该方法向或者从数组中添加或者删除项目，返回被删除的项目（会改变原数组） 

      ```
      //1开始下标 2结束下标
      var arr = [1,2,3,4,5];
      console.log(arr.slice(1,3))//[2,3]  不包含end，序列号为3的元素
      
      
      //1截取开始下标 2截取多少个（必须） 3新项目
      var arr = [1,2,3,4,5];
      console.log(arr.splice(2,1,"hello"));//[3]  返回的新数组
      console.log(arr);//[1, 2, "hello", 4, 5]  改变了原数组
      //同样也可以用于插入元素
      arr.splice(2,0,'abc') //[1,2,'abc',3,4,5] 
      ```

18. `WATCH`监听对象

    首先确认 watch是一个对象，一定要当成对象来用。对象就有键，有值。
    键：就是你要监控的那个家伙，比如说$route，这个就是要监控路由的变化。或者是data中的某个变量。
    **值可以是函数**：就是当你监控的家伙变化时，需要执行的函数，这个函数有两个形参，第一个是当前值，第二个是变化后的值。
    **值是包括选项的对象**：选项包括有三个。
    1.第一个`handler`：其值是一个回调函数。即监听到变化时应该执行的函数。
    2.第二个是`deep`：其值是true或false；确认是否深入监听。（一般监听时是不能监听到对象属性值的变化的，数组的值变化可以听到。）
    3.第三个是`immediate`：其值是true或false；确认是否以当前的初始值执行handler的函数( **初始化立即执行** )

    ```
    //不要使用箭头函数定义watch函数
    watch: {
    	value: (newV, oldV) => {
    	this.a = newV; // this => undefined
    	}
    }
    ```

     ![img](https://img-blog.csdnimg.cn/20181113191230365.png) 

19. 鼠标事件的各个参数在页面上的位置 -- **鼠标事件以及clientX、offsetX、screenX、pageX、x的区别**

    >  https://blog.csdn.net/weixin_41342585/article/details/80659736

20. 子组件修改父组件传递的prop属性值， 需要对一个 prop 进行“双向绑定”。但是破坏了单向数据流的设计，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。 

    >  [https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-修饰符) 

    ```
     update:myPropName   
     
     this.$emit('update:title', newTitle)   //子组件触发数据更新
     
     //监听
     <text-document
      v-bind:title="doc.title"
      v-on:update:title="doc.title = $event"
    ></text-document>
     //使用sync简化
     <text-document :title.sync="doc.title"></text-document>
     
    
```
    
22. 做题目的时候发现split还有骚用法，可以传入一个正则表达式。（题目要求按空格分隔字符串，但是空格的数目不定）

     ```
     //可以在参数传入正则表达式 
     let str = "a  bbb cccc"
     str.split(/\s+/) // -->输出：[a,bbb,ccc]
     ```

     